'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
class BasicHashbeltMap {
  // BasicHashbeltMap
  //   options: @{}
  //     create  --  function that returns a Map-compatible object,
  //                 implementing has(), get(), set(), delete(), entries(), and clear()
  //     tip     --  initial Map-compatible object to use as the tip

  constructor(opts) {
    if (null == opts) {
      opts = {};
    } else if ('function' === typeof opts) {
      opts = { create: opts };
    }

    const createTip = 'function' === typeof opts.create ? opts.create.bind(opts) : () => new Map();

    const tip = null != opts.tip ? opts.tip : createTip();

    Object.defineProperties(this, {
      _createTip: { value: createTip },
      _belt: { writable: true, value: [tip] },
      _tid: { writable: true, value: null } });
  }

  setAutoRotateInterval(ms_delay) {
    if (this._tid) {
      clearInterval(this._tid);
    }
    if (null != ms_delay) {
      const tid = setInterval(() => this.rotate(), ms_delay);
      if ('function' === typeof tid.unref) {
        tid.unref();
      }
      this._tid = tid;
    }
    return this;
  }

  rotate() {
    this._belt = this._cull_hashbelt([this._createTip()].concat(this._belt));
    return this;
  }

  _cull_hashbelt(belt) {
    return belt;
  }

  has(key) {
    for (const each of this._belt) {
      if (each.has(key)) {
        this._hit_has(key, each);
        return true;
      }
    }

    return !!this._miss_has(key);
  }

  _hit_has(key, coll) {}
  _miss_has(key) {}

  get(key) {
    for (const each of this._belt) {
      if (each.has(key)) {
        const value = each.get(key);
        this._hit_get(key, value, each);
        return value;
      }
    }
    return this._miss_get(key);
  }

  _hit_get(key, value, coll) {}
  _miss_get(key) {}

  set(key, value) {
    const tip = this._belt[0];
    this._hit_set(key, value, tip);
    tip.set(key, value);
    return this;
  }

  _hit_set(key, value, coll) {}

  delete(key) {
    for (const each of this._belt) {
      if (each.has(key)) {
        this._hit_delete(key, each);
        return each.delete(key);
      }
    }

    return !!this._miss_delete(key);
  }

  _hit_delete(key, coll) {}
  _miss_delete(key) {}

  clear() {
    const previous = this._belt;
    this._belt = [new this._createTip()];

    if (previous) {
      for (const each of previous) {
        each.clear();
      }
    }
  }

  *entries() {
    const seen = new Set();
    let sz = seen.size;

    for (const each of this._belt) {
      for (const entry of each.entries()) {
        seen.add(entry[0]);
        if (sz !== seen.size) {
          sz = seen.size;
          yield entry;
        }
      }
    }
  }

  [Symbol.iterator]() {
    return this.entries();
  }
  *keys() {
    for (const entry of this.entries()) {
      yield entry[0];
    }
  }
  *values() {
    for (const entry of this.entries()) {
      yield entry[1];
    }
  }
  forEach(callback, thisArg) {
    return new Map(this.entries()).forEach(callback, thisArg);
  }
}exports.BasicHashbeltMap = BasicHashbeltMap;
class HashbeltMap extends BasicHashbeltMap {
  constructor(opts) {
    if (null == opts) {
      opts = {};
    }
    super(opts);
    Object.defineProperties(this, {
      capacity: { value: opts.capacity || 5 } });
  }

  _cull_hashbelt(belt) {
    const capacity = this.capacity;
    if (null != capacity) {
      belt = belt.slice(0, this.capacity);
    }
    return belt;
  }

  autoRotate(ms_delay = 60000) {
    return this.setAutoRotateInterval(ms_delay);
  }
}exports.HashbeltMap = HashbeltMap;
const Hashbelt = exports.Hashbelt = HashbeltMap;

class ReadCachingHashbeltMap extends HashbeltMap {
  _hit_get(key, value, coll) {
    // copy the hit to the front of the cache
    const tip = this._belt[0];
    tip.set(key, value);
  }
}exports.ReadCachingHashbeltMap = ReadCachingHashbeltMap;
const CachingHashbeltMap = exports.CachingHashbeltMap = ReadCachingHashbeltMap;
const CachingHashbelt = exports.CachingHashbelt = ReadCachingHashbeltMap;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL2NvZGUvaW5kZXguanN5Il0sIm5hbWVzIjpbIkJhc2ljSGFzaGJlbHRNYXAiLCJjb25zdHJ1Y3RvciIsIm9wdHMiLCJjcmVhdGUiLCJjcmVhdGVUaXAiLCJiaW5kIiwiTWFwIiwidGlwIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydGllcyIsIl9jcmVhdGVUaXAiLCJ2YWx1ZSIsIl9iZWx0Iiwid3JpdGFibGUiLCJfdGlkIiwic2V0QXV0b1JvdGF0ZUludGVydmFsIiwibXNfZGVsYXkiLCJjbGVhckludGVydmFsIiwidGlkIiwic2V0SW50ZXJ2YWwiLCJyb3RhdGUiLCJ1bnJlZiIsIl9jdWxsX2hhc2hiZWx0IiwiY29uY2F0IiwiYmVsdCIsImhhcyIsImtleSIsImVhY2giLCJfaGl0X2hhcyIsIl9taXNzX2hhcyIsImNvbGwiLCJnZXQiLCJfaGl0X2dldCIsIl9taXNzX2dldCIsInNldCIsIl9oaXRfc2V0IiwiZGVsZXRlIiwiX2hpdF9kZWxldGUiLCJfbWlzc19kZWxldGUiLCJjbGVhciIsInByZXZpb3VzIiwiZW50cmllcyIsInNlZW4iLCJTZXQiLCJzeiIsInNpemUiLCJlbnRyeSIsImFkZCIsIlN5bWJvbCIsIml0ZXJhdG9yIiwia2V5cyIsInZhbHVlcyIsImZvckVhY2giLCJjYWxsYmFjayIsInRoaXNBcmciLCJIYXNoYmVsdE1hcCIsImNhcGFjaXR5Iiwic2xpY2UiLCJhdXRvUm90YXRlIiwiSGFzaGJlbHQiLCJSZWFkQ2FjaGluZ0hhc2hiZWx0TWFwIiwiQ2FjaGluZ0hhc2hiZWx0TWFwIiwiQ2FjaGluZ0hhc2hiZWx0Il0sIm1hcHBpbmdzIjoiOzs7OztBQUNPLE1BQU1BLGdCQUFOLENBQXVCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUFDLGNBQVlDLElBQVosRUFBa0I7QUFDaEIsUUFBRyxRQUFRQSxJQUFYLEVBQWtCO0FBQUNBLGFBQU8sRUFBUDtBQUFTLEtBQTVCLE1BQ0ssSUFBRyxlQUFlLE9BQU9BLElBQXpCLEVBQWdDO0FB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QU1JLDhCQUFXSixXQUFqQjs7QUFJQSxNQUFNSyxzQkFBTixTQUFxQ0wsV0FBckMsQ0FBaUQ7QUFDdER2QixXQUFTTixHQUFULEVBQWNmLEtBQWQsRUFBcUJtQixJQUFyQixFQUEyQjtBQUN6QjtBQUNBLFVBQU12QixNQUFNLEtBQUtLLEtBQUwsQ0FBVyxDQUFYLENBQVo7QUFDQUwsUUFBSTJCLEdBQUosQ0FBUVIsR0FBUixFQUFhZixLQUFiO0FBQW1CO0FBSmlDLEMsUUFBM0NpRCxzQixHQUFBQSxzQjtBQU1OLE1BQU1DLGtEQUFxQkQsc0JBQTNCO0FBQ0EsTUFBTUUsNENBQWtCRixzQkFBeEIiLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzQ29udGVudCI6WyJcbmV4cG9ydCBjbGFzcyBCYXNpY0hhc2hiZWx0TWFwIDo6XG4gIC8vIEJhc2ljSGFzaGJlbHRNYXBcbiAgLy8gICBvcHRpb25zOiBAe31cbiAgLy8gICAgIGNyZWF0ZSAgLS0gIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIE1hcC1jb21wYXRpYmxlIG9iamVjdCxcbiAgLy8gICAgICAgICAgICAgICAgIGltcGxlbWVudGluZyBoYXMoKSwgZ2V0KCksIHNldCgpLCBkZWxldGUoKSwgZW50cmllcygpLCBhbmQgY2xlYXIoKVxuICAvLyAgICAgdGlwICAgICAtLSAgaW5pdGlhbCBNYXAtY29tcGF0aWJsZSBvYmplY3QgdG8gdXNlIGFzIHRoZSB0aXBcblxuICBjb25zdHJ1Y3RvcihvcHRzKSA6OlxuICAgIGlmIG51bGwgPT0gb3B0cyA6OiBvcHRzID0ge31cbiAgICBlbHNlIGlmICdmdW5jdGlvbicgPT09IHR5cGVvZiBvcHRzIDo6XG4gICAgICBvcHRzID0gQDogY3JlYXRlOiBvcHRzXG5cbiAgICBjb25zdCBjcmVhdGVUaXAgPSAnZnVuY3Rpb24nID09PSB0eXBlb2Ygb3B0cy5jcmVhdGVcbiAgICAgID8gb3B0cy5jcmVhdGUuYmluZChvcHRzKVxuICAgICAgOiAoKSA9PiBuZXcgTWFwKClcblxuICAgIGNvbnN0IHRpcCA9IG51bGwgIT0gb3B0cy50aXBcbiAgICAgID8gb3B0cy50aXAgOiBjcmVhdGVUaXAoKVxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgQCB0aGlzLCBAOlxuICAgICAgX2NyZWF0ZVRpcDogQDogdmFsdWU6IGNyZWF0ZVRpcFxuICAgICAgX2JlbHQ6IEA6IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogW3RpcF1cbiAgICAgIF90aWQ6IEA6IHdyaXRhYmxlOiB0cnVlLCB2YWx1ZTogbnVsbFxuXG5cbiAgc2V0QXV0b1JvdGF0ZUludGVydmFsKG1zX2RlbGF5KSA6OlxuICAgIGlmIHRoaXMuX3RpZCA6OiBjbGVhckludGVydmFsKHRoaXMuX3RpZClcbiAgICBpZiBudWxsICE9IG1zX2RlbGF5IDo6XG4gICAgICBjb25zdCB0aWQgPSBzZXRJbnRlcnZhbCBAICgpID0+IHRoaXMucm90YXRlKCksIG1zX2RlbGF5XG4gICAgICBpZiAnZnVuY3Rpb24nID09PSB0eXBlb2YgdGlkLnVucmVmIDo6XG4gICAgICAgIHRpZC51bnJlZigpXG4gICAgICB0aGlzLl90aWQgPSB0aWRcbiAgICByZXR1cm4gdGhpc1xuXG4gIHJvdGF0ZSgpIDo6XG4gICAgdGhpcy5fYmVsdCA9IHRoaXMuX2N1bGxfaGFzaGJlbHQgQFxuICAgICAgW3RoaXMuX2NyZWF0ZVRpcCgpXVxuICAgICAgICAuY29uY2F0IEAgdGhpcy5fYmVsdFxuICAgIHJldHVybiB0aGlzXG5cbiAgX2N1bGxfaGFzaGJlbHQoYmVsdCkgOjogcmV0dXJuIGJlbHRcblxuXG5cbiAgaGFzKGtleSkgOjpcbiAgICBmb3IgY29uc3QgZWFjaCBvZiB0aGlzLl9iZWx0IDo6XG4gICAgICBpZiBlYWNoLmhhcyhrZXkpIDo6XG4gICAgICAgIHRoaXMuX2hpdF9oYXMoa2V5LCBlYWNoKVxuICAgICAgICByZXR1cm4gdHJ1ZVxuXG4gICAgcmV0dXJuICEhIHRoaXMuX21pc3NfaGFzKGtleSlcblxuICBfaGl0X2hhcyhrZXksIGNvbGwpIDo6XG4gIF9taXNzX2hhcyhrZXkpIDo6XG5cblxuICBnZXQoa2V5KSA6OlxuICAgIGZvciBjb25zdCBlYWNoIG9mIHRoaXMuX2JlbHQgOjpcbiAgICAgIGlmIGVhY2guaGFzKGtleSkgOjpcbiAgICAgICAgY29uc3QgdmFsdWUgPSBlYWNoLmdldChrZXkpXG4gICAgICAgIHRoaXMuX2hpdF9nZXQoa2V5LCB2YWx1ZSwgZWFjaClcbiAgICAgICAgcmV0dXJuIHZhbHVlXG4gICAgcmV0dXJuIHRoaXMuX21pc3NfZ2V0KGtleSlcblxuICBfaGl0X2dldChrZXksIHZhbHVlLCBjb2xsKSA6OlxuICBfbWlzc19nZXQoa2V5KSA6OlxuXG5cbiAgc2V0KGtleSwgdmFsdWUpIDo6XG4gICAgY29uc3QgdGlwID0gdGhpcy5fYmVsdFswXVxuICAgIHRoaXMuX2hpdF9zZXQoa2V5LCB2YWx1ZSwgdGlwKVxuICAgIHRpcC5zZXQoa2V5LCB2YWx1ZSlcbiAgICByZXR1cm4gdGhpc1xuXG4gIF9oaXRfc2V0KGtleSwgdmFsdWUsIGNvbGwpIDo6XG5cblxuICBkZWxldGUoa2V5KSA6OlxuICAgIGZvciBjb25zdCBlYWNoIG9mIHRoaXMuX2JlbHQgOjpcbiAgICAgIGlmIGVhY2guaGFzKGtleSkgOjpcbiAgICAgICAgdGhpcy5faGl0X2RlbGV0ZShrZXksIGVhY2gpXG4gICAgICAgIHJldHVybiBlYWNoLmRlbGV0ZShrZXkpXG5cbiAgICByZXR1cm4gISEgdGhpcy5fbWlzc19kZWxldGUoa2V5KVxuXG4gIF9oaXRfZGVsZXRlKGtleSwgY29sbCkgOjpcbiAgX21pc3NfZGVsZXRlKGtleSkgOjpcblxuXG5cbiAgY2xlYXIoKSA6OlxuICAgIGNvbnN0IHByZXZpb3VzID0gdGhpcy5fYmVsdFxuICAgIHRoaXMuX2JlbHQgPSBbbmV3IHRoaXMuX2NyZWF0ZVRpcCgpXVxuXG4gICAgaWYgcHJldmlvdXMgOjpcbiAgICAgIGZvciBjb25zdCBlYWNoIG9mIHByZXZpb3VzIDo6XG4gICAgICAgIGVhY2guY2xlYXIoKVxuXG5cbiAgKmVudHJpZXMoKSA6OlxuICAgIGNvbnN0IHNlZW4gPSBuZXcgU2V0KClcbiAgICBsZXQgc3ogPSBzZWVuLnNpemVcblxuICAgIGZvciBjb25zdCBlYWNoIG9mIHRoaXMuX2JlbHQgOjpcbiAgICAgIGZvciBjb25zdCBlbnRyeSBvZiBlYWNoLmVudHJpZXMoKSA6OlxuICAgICAgICBzZWVuLmFkZChlbnRyeVswXSlcbiAgICAgICAgaWYgc3ogIT09IHNlZW4uc2l6ZSA6OlxuICAgICAgICAgIHN6ID0gc2Vlbi5zaXplXG4gICAgICAgICAgeWllbGQgZW50cnlcblxuICBbU3ltYm9sLml0ZXJhdG9yXSgpIDo6XG4gICAgcmV0dXJuIHRoaXMuZW50cmllcygpXG4gICprZXlzKCkgOjpcbiAgICBmb3IgY29uc3QgZW50cnkgb2YgdGhpcy5lbnRyaWVzKCkgOjpcbiAgICAgIHlpZWxkIGVudHJ5WzBdXG4gICp2YWx1ZXMoKSA6OlxuICAgIGZvciBjb25zdCBlbnRyeSBvZiB0aGlzLmVudHJpZXMoKSA6OlxuICAgICAgeWllbGQgZW50cnlbMV1cbiAgZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZykgOjpcbiAgICByZXR1cm4gbmV3IE1hcCh0aGlzLmVudHJpZXMoKSkuZm9yRWFjaChjYWxsYmFjaywgdGhpc0FyZylcblxuXG5cbmV4cG9ydCBjbGFzcyBIYXNoYmVsdE1hcCBleHRlbmRzIEJhc2ljSGFzaGJlbHRNYXAgOjpcbiAgY29uc3RydWN0b3Iob3B0cykgOjpcbiAgICBpZiBudWxsID09IG9wdHMgOjogb3B0cyA9IHt9XG4gICAgc3VwZXIob3B0cylcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyBAIHRoaXMsIEA6XG4gICAgICAgIGNhcGFjaXR5OiBAOiB2YWx1ZTogb3B0cy5jYXBhY2l0eSB8fCA1XG5cbiAgX2N1bGxfaGFzaGJlbHQoYmVsdCkgOjpcbiAgICBjb25zdCBjYXBhY2l0eSA9IHRoaXMuY2FwYWNpdHlcbiAgICBpZiBudWxsICE9IGNhcGFjaXR5IDo6XG4gICAgICBiZWx0ID0gYmVsdC5zbGljZSBAIDAsIHRoaXMuY2FwYWNpdHlcbiAgICByZXR1cm4gYmVsdFxuXG4gIGF1dG9Sb3RhdGUobXNfZGVsYXk9NjAwMDApIDo6XG4gICAgcmV0dXJuIHRoaXMuc2V0QXV0b1JvdGF0ZUludGVydmFsKG1zX2RlbGF5KVxuXG5leHBvcnQgY29uc3QgSGFzaGJlbHQgPSBIYXNoYmVsdE1hcFxuXG5cblxuZXhwb3J0IGNsYXNzIFJlYWRDYWNoaW5nSGFzaGJlbHRNYXAgZXh0ZW5kcyBIYXNoYmVsdE1hcCA6OlxuICBfaGl0X2dldChrZXksIHZhbHVlLCBjb2xsKSA6OlxuICAgIC8vIGNvcHkgdGhlIGhpdCB0byB0aGUgZnJvbnQgb2YgdGhlIGNhY2hlXG4gICAgY29uc3QgdGlwID0gdGhpcy5fYmVsdFswXVxuICAgIHRpcC5zZXQoa2V5LCB2YWx1ZSlcblxuZXhwb3J0IGNvbnN0IENhY2hpbmdIYXNoYmVsdE1hcCA9IFJlYWRDYWNoaW5nSGFzaGJlbHRNYXBcbmV4cG9ydCBjb25zdCBDYWNoaW5nSGFzaGJlbHQgPSBSZWFkQ2FjaGluZ0hhc2hiZWx0TWFwXG5cbiJdfQ==